# Curso de Introducci√≥n a Selenium con Python

## Conocer el ecosistema de Selenium

### Bienvenida al curso

### Historia de Selenium

¬øQu√© es selenium?: Es una suite de heramientas para **automatizaci√≥n** de navegadores.

Selenium es compatbile con los navegadores web m√°s populares y algunos lenguajes de programaci√≥n; Java, C#, Kotlin, Perl, Php, Python, Ruby, JavaScript.

**Importante**: Selenium **NO** es una herramienta de testing ni web scraping (aunque se puede usar para esto, no es su enfoque).

Para este curso, cuando mencionemos "Selenium" nos estaremos refiriendo espec√≠ficamente a [Selenium WebDriver](https://www.selenium.dev/).

*Dato curioso*: El origen del nombre es por "Selenio", que es medicina para el envenenamiento por mercurio.

**Importante**: Selenium **NO** es un software, sino una suite de distintos softwares.

Pros de Selenium IDE:

- Excelente para iniciar en Testing y Pruebas unitarias
- No requiere saber programar
- Exporta scripts para Selenium RC y Selenium WebDriver
- Genera reportes

Contras de Selenium IDE:

- Disponible solo para Firefox y Chrome
- No sorporta DDT (Data Driven Testing)

Pros de Selenium RC:

- Soporte para:
  - Varias plataformas, navegadores y lenguajes
  - Operaciones l√≥gicas y condicionales
  - DDT
- Posee una API madura

Contras de Selenium RC:

- Complejo de instalar
- Necesita de un servidor corriendo
- Comandos redundants y ambig√ºos en su API
- Navegaci√≥n no tan realista

Pros de Selenium WebDriver:

- Soporte para m√∫ltiples lenguajes
- F√°cil de instalar
- Comunicaci√≥n directa con el navegador
- Interacci√≥n m√°s realista

Constras de Selenium WebDriver:

- No soporta nuevos navegadores tan r√°pido
- No genera reportes o resultados de pruebas
- Requiere de saber programar (Pero con Platzi esto no es desventaja (; )

Sobre Selenium Grid:

- Se utiliza junto a Selenium RC
- Permite correr pruebas en paralelo
- Conveniente para ahorrar tiempo

### Otras herramientas de testing y automatizaci√≥n

- [Puppeteer](https://pptr.dev/)
- [Cypress.io](https://www.cypress.io/)

Ninguna es mejor que la otra, todo depende de tus necesidades y condiciones.

## Preparar entorno de trabajo

### Configurar entorno de trabajo

Deberemos instalar:

- [Python](https://www.python.org/downloads/)
- Selenium -> En la terminal (tipo unix) `pip3 install selenium`
- PyUnitReport -> En la terminal (tipo unix) `pip3 install pyunitreport`

### Hola mundo

Cosas importantes de Unittest (PyTest)

- *Test Fixture*: preparaciones para antes y despu√©s de la prueba
- *Test Case*: unidad de c√≥digo a probar
- *Test Suite*: colecci√≥n de Test Cases
- *Test Runner*: orquestador de la ejecuci√≥n
- *Test Report*: resumen de resultados

#### Creando entorno virtual en python 3.8

1. Instalar: `sudo apt-get install python3.8-venv`
2. Ejecutar: `sudo python3.8 -m venv nombreDelProyecto`
3. Crear alias: `alias avenv="source venv/bin/activate"` (venv es el nombre del proyecto)
4. Ejecutar alias: `avenv`

[Para instalar Chrome en Ubuntu 20.04](https://linuxize.com/post/how-to-install-google-chrome-web-browser-on-ubuntu-20-04/)

`wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb`

`sudo apt install ./google-chrome-stable_current_amd64.deb`

[Para instalar chromium driver en Ubuntu](https://www.gregbrisebois.com/posts/chromedriver-in-wsl2/)

***IMPORTANTE***: Para poder instalar con pip las librer√≠as solamente en el entorno virutal de Python, hay que modificar el archivo "pyvenv.cfg"

```python
home = /usr/bin
include-system-site-packages = true #!debe estar en true
version = 3.8.5
```

Si no deja modificar, ejecutar: `sudo chown -r nombre_de_usuario directorio_del_proyecto`, en mi caso fue: `sudo chown -r mike_angel_rm /home/mike_angel_rm/personalProjects/CursoIntroduccionSeleniumPython`

Apagamos el entorno virtual y lo volvemos a encender. Instalamos las librer√≠as.

Si el c√≥digo no funciona, esto funcion√≥ para m√≠ en WSL2:

hello_world.py:

```python
import unittest
from pyunitreport import HTMLTestRunner
from selenium import webdriver
from selenium.webdriver.chrome.options import Options

class HelloWorld(unittest.TestCase):

  @classmethod
  def setUpClass(cls): # Qu√© es lo que se va a hacer
    options = Options()
    options.add_argument('--headless')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    cls.driver = webdriver.Chrome(executable_path = '/usr/bin/chromedriver' , options=options) #Ruta de driver en unix
    driver = cls.driver # Para no tener que escribir self driver en cada l√≠nea
    #driver.implicity_wait(10)


  def test_hello_world(self):
    driver = self.driver
    driver.get('https://www.platzi.com')


  def test_visit_wikipedia(self):
    driver = self.driver
    driver.get('https://www.wikipedia.org')


  @classmethod
  def tearDownClass(cls):
    cls.driver.quit() # Cerramos la ventana del navegador despu√©s de cada prueba


if __name__ == '__main__':
  # output es el nombre del reporte
  unittest.main(verbosity=2 , testRunner= HTMLTestRunner(output = 'reportes', report_name='hello-world-report'))
```

Es ***importante*** tener chrome/chromium y chromedriver instalados en WSL2.

## Utilizar comandos b√°sicos

### Encontrar elementos con find_element

En Selenium, podemos usar los selectores de las p√°ginas web para llegar a los elementos, como son:

- ID
- Nombre del atributo
- Nombre de la clase
- Nombre de la etiqueta
- XPath -> Ruta de nodos en XML que indica la ubicaci√≥n exacta de d√≥nde se encuentra un elemento. NO es la mejor opci√≥n, pues los elementos de una p√°gina web pueden cambiar.
- Selector de CSS
- Texto del link
- Texto parcial del link

Podemos practicar en [Madison Island](http://demo-store.seleniumacademy.com/) (Es un e-commerce falso para practicar).

Instrucciones usadas en esta clase:

- `self.driver.find_element_by_id` -> Encontrar elemento por su ID
- `self.driver.find_element_by_name` -> Encontrar elemento por su name
- `self.driver.find_element_by_class_name` -> Encontrar elemento por nombre de clase CSS
- `find_elements_by_tag_name` -> Encontrar elementos por sus etiquetas HTML
- `self.driver.find_element_by_xpath` -> Encontrar elemento por su XPATH
- `self.driver.find_element_by_css_selector` -> Encontrar elemento por su selector CSS

C√≥digo de la clase (en WSL):

search_test.py

```python
import unittest
from pyunitreport import HTMLTestRunner
from selenium import webdriver
from selenium.webdriver.chrome.options import Options


class HelloWorld(unittest.TestCase):

  @classmethod
  def setUpClass(cls):
    options = Options()
    options.add_argument('--headless')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    cls.driver = webdriver.Chrome(executable_path = '/usr/bin/chromedriver' , options=options)
    driver = cls.driver
    driver.get('http://demo-store.seleniumacademy.com/')
    #driver.maximize_window()
    #driver.implicitly_wait(15) # segundos


  def test_search_text_fild(self):
    search_field = self.driver.find_element_by_id("search")


  def test_search_text_field_by_name(self):
    search_field = self.driver.find_element_by_name("q")


  def test_search_text_field_class_name(self):
    search_field = self.driver.find_element_by_class_name("input-text")


  def test_search_button_enabled(self):
    button = self.driver.find_element_by_class_name("button")


  def test_count_of_promo_banner_images(self):
    banner_list = self.driver.find_element_by_class_name("promos") #Buscamos la clase "promos"
    banners = banner_list.find_elements_by_tag_name("img") #Buscamos las etiquetas img dentro de promos
    self.assertEqual(3, len(banners)) #Hacemos una assertion para ver si efectivamente es la cantidad de im√°genes que esperamos
    #! NO son 3 im√°genes, son 4, pero recordemos que se cuenta: [0,1,2,3]


  def test_vip_promo(self):
    vip_promo = self.driver.find_element_by_xpath('//*[@id="top"]/body/div/div[2]/div[2]/div/div/div[2]/div[1]/ul/li[4]/a/img')


  def test_shopping_cart(self):
    shopping_cart_icon = self.driver.find_element_by_css_selector("div.header-minicart span.icon")


  @classmethod
  def tearDownClass(cls):
    cls.driver.quit()


if __name__ == '__main__':
  unittest.main(verbosity = 2)
```

### Preparar assertions y test suites

Con estos 2 elementos podemos hacer pruebas que sean m√°s efectivas.

*Assertions*: Son m√©todos que permiten validar un valor esperado en la ejecuci√≥n del test. Si el resultado es verdadero el test contin√∫a, en caso contrario "falla" y termina. Ejemplo: `assertEqual(price.text, "300")`

*Test Suites*: Colecci√≥n de test unificados en una sola prueba, permitiendo tener resultados grupales e individuales.

[PDF de m√©todos de Selenium](https://static.platzi.com/media/public/uploads/archivo_complementario_assertions_test_suites_e4ace318-3bc2-47e1-8c39-a3bdeed25f48.pdf)

Tenemos creados los archivos "assertions.py" y "searchTests.py". Creamos un nuevo archivo para ejecutar ambas pruebas en paralelo, se llamar√° "smoke_test.py"

assertions.py:

```python
import unittest
from pyunitreport import HTMLTestRunner
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import NoSuchElementException # Nos servir√° como excepci√≥n para validar la presencia de un elemento
from selenium.webdriver.common.by import By # Nos ayudar√° a llamar a las excepciones que queremos validar

class AssertionsTest(unittest.TestCase):

  @classmethod
  def setUpClass(cls):
    options = Options()
    options.add_argument('--headless')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    cls.driver = webdriver.Chrome(executable_path = '/usr/bin/chromedriver' , options=options)
    driver = cls.driver
    driver.get('http://demo-store.seleniumacademy.com/')


  def test_search_field(self):
    self.assertTrue(self.is_element_present(By.NAME, 'q')) # ¬øExiste un elemento con atributo NAME de valor 'q'?


  def test_language_option(self):
    self.assertTrue(self.is_element_present(By.ID, 'select-language')) # ¬øExiste un elemento con atributo ID de valor 'select-language'?


  @classmethod
  def tearDownClass(cls):
    cls.driver.quit()


  def is_element_present(self, how, what): #Verificaremos si un elemento est√° presente de acuerdo a estos par√°metros. "How" indicar√° el tipo de selectot y "What" el valor que tiene
    try:
      self.driver.find_element(by = how, value = what)
    except NoSuchElementException as variable:
      return False
    return True


if __name__ == '__main__':
  unittest.main(verbosity = 2)
```

searchTests.py:

```python
import unittest
from pyunitreport import HTMLTestRunner
from selenium import webdriver
from selenium.webdriver.chrome.options import Options

class Search_Tests(unittest.TestCase):

  @classmethod
  def setUpClass(cls):
    options = Options()
    options.add_argument('--headless')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    cls.driver = webdriver.Chrome(executable_path = '/usr/bin/chromedriver' , options=options)
    driver = cls.driver
    driver.get('http://demo-store.seleniumacademy.com/')


  def test_search_tee(self):
    driver = self.driver
    search_field = driver.find_element_by_name('q')
    search_field.clear() #Limpiar√° el campo de b√∫squeda en caso de que haya alg√∫n texto
    search_field.send_keys('tee') #Simulamos que escribimos 'tee' (camisa en ingl√©s)
    search_field.submit() #Env√≠a los datos


  def test_search_salt_shaker(self):
    driver = self.driver
    search_field = driver.find_element_by_name('q')
    search_field.send_keys('salt shaker')
    search_field.submit()

    products = driver.find_elements_by_xpath('//*[@id="top"]/body/div/div[2]/div[2]/div/div[2]/div[2]/div[3]/ul/li/div/h2/a')
    self.assertEqual(1, len(products))


  @classmethod
  def tearDownClass(cls):
    cls.driver.quit()


if __name__ == '__main__':
  unittest.main(verbosity = 2)
```

smoke_test.py:

```python
from unittest import TestLoader, TestSuite
from pyunitreport import HTMLTestRunner
from assertions import AssertionsTest
from searchTests import Search_Tests

assertions_test = TestLoader().loadTestsFromTestCase(AssertionsTest) # Nombre de la clase de prueba
search_test = TestLoader().loadTestsFromTestCase(Search_Tests) # Nombre de la clase de prueba

# Construyendo suite de pruebas
smoke_test = TestSuite([assertions_test, search_test])

kwargs = {
  "output": "smoke-report"
}

runner = HTMLTestRunner(**kwargs)
runner.run(smoke_test)
```

### Entender las clases WebDriver y WebElement

Como viste en clases anteriores, un sitio web se construye por c√≥digo HTML en forma de √°rbol, conteniendo distintos elementos con los que podemos interactuar seg√∫n est√©n presentes o no en nuestra interfaz gr√°fica.

Selenium WebDriver nos brinda la posibilidad de poder referirnos a estos elementos y ejecutar m√©todos espec√≠ficos para realizar las mismas acciones que un humano har√≠a sobre los mismos, gracias a las clases WebDriver y WebElement.

#### Clase WebDriver

Cuenta con una serie de propiedades y m√©todos para interactuar directamente con la ventana del navegador y sus elementos relacionados, como son pop-ups o alerts. Por ahora nos centraremos a las m√°s utilizadas.

#### Propiedades de la clase WebDriver

Estas son las m√°s comunes para acceder al navegador.

Propiedad/Atributo|Descripci√≥n|Ejemplo
|---|---|---|
current_url|Obtiene la URL del sitio en la que se encuentra el navegador|driver.get_url
current_window_handle|Obtiene la referencia que identifica a la ventana activa en ese momento|driver.current_window_handle
name|Obtiene el nombre del navegador subyacente para la instancia activa|driver.name
orientation|Obtiene la orientaci√≥n actual del dispositivo m√≥vil|driver.orientation
page_source|Obtiene el c√≥digo fuente de disponible del sitio web|driver.page_source
title|Obtiene el valor de la etiqueta `<title>` del sitio web|driver.title

#### Clase WebElement

Esta clase nos permite interactuar espec√≠ficamente con elementos de los sitios web como textbox, text area, button, radio button, checkbox, etc.

#### Propiedades m√°s comunes de la clase WebElement

Propiedad/Atributo|Descripci√≥n|Ejemplo
|---|---|---|
size|Obtiene el tama√±o del elemento|login.size
tag_name|Obtiene el nombre de la etiqueta HTML del elemento|login.tag_name
text|Obtiene el texto del elemento|login.text

#### M√©todos m√°s comunes de la clase WebElement

Propiedad/Atributo|Descripci√≥n|Ejemplo
|---|---|---|
clear()|Limpia el contenido de un textarea|first_name.clear()
click()|Hace clic en el elemento|send_button.click()
get_attribute(name)|Obtiene el valor del atributo de un elemento|submit_button.get_attribute(‚Äòvalue‚Äô) last_name.get_attribute(max_length)
is_displayed()|Verifica si el elemento est√° a la vista al usuario|banner.is_displayed()
is_enabled()|Verifica si el elemento est√° habilitado|radio_button.is_enabled()
is_selected()|Verifica si el elemento est√° seleccionado, para el caso de checkbox o radio button|checkbox.is_selected()
send_keys(value)|Simula escribir o presionar teclas en un elemento|email_field.send_keys(‚Äòteam@platzi.com‚Äô)
submit()|Env√≠a un formulario o confirmaci√≥n en un text area|search_field.submit()
value_of_css_property(property_name)|Obtiene el valor de una propiedad CSS del elemento|header.value_of_css_property(‚Äòbackground-color‚Äô)

## Interactuar con elementos

### Manejar form, textbox, chckbox y radio button

Pudimos simular un registro de un usuario en la p√°gina con el siguiente c√≥digo:

register_new_user.py:

```python
import unittest
from pyunitreport import HTMLTestRunner
from selenium import webdriver
from selenium.webdriver.chrome.options import Options

class RegisterNewUser(unittest.TestCase):

  @classmethod
  def setUpClass(cls):
    options = Options()
    options.add_argument('--headless')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    cls.driver = webdriver.Chrome(executable_path = '/usr/bin/chromedriver' , options=options)
    driver = cls.driver
    driver.get('http://demo-store.seleniumacademy.com/')


  def test_new_user(self):
    driver = self.driver
    driver.find_element_by_xpath('/html/body/div/div[2]/header/div/div[2]/div/a/span[2]').click() #Hacemos click en el elemento
    driver.find_element_by_link_text('Log In').click()

    create_account_button = driver.find_element_by_xpath('//*[@id="login-form"]/div/div[1]/div[2]/a/span/span')
    self.assertTrue(create_account_button.is_displayed() and create_account_button.is_enabled())
    create_account_button.click()

    self.assertEqual('Create New Customer Account' , driver.title) #¬øEl t√≠tulo de la p√°gina web es igual al t√≠tulo del driver?

    #Creamos las variables para encontrar los elementos
    first_name = driver.find_element_by_id('firstname')
    middle_name = driver.find_element_by_id('middlename')
    last_name = driver.find_element_by_id('lastname')
    email_address = driver.find_element_by_id('email_address')
    news_letter_suscription = driver.find_element_by_id('is_subscribed')
    password = driver.find_element_by_id('password') #! No utilizar datos reales por la sensibilidad de los datos
    confirm_password = driver.find_element_by_id('confirmation')
    submit_button = driver.find_element_by_xpath('/html/body/div/div[2]/div[2]/div/div/div[2]/form/div[2]/button/span/span')

    #Verificamos que los elementos est√©n habilitados
    self.assertTrue(first_name.is_enabled()
    and middle_name.is_enabled()
    and last_name.is_enabled()
    and email_address.is_enabled()
    and news_letter_suscription.is_enabled()
    and password.is_enabled()
    and confirm_password.is_enabled()
    and submit_button.is_enabled())

    #Pretendemos llenar los campos
    first_name.send_keys('Test')
    middle_name.send_keys('Test')
    last_name.send_keys('Test')
    email_address.send_keys('Test@testingmail.com')
    password.send_keys('Test')
    confirm_password.send_keys('Test')
    news_letter_suscription.click()
    submit_button.click()


  @classmethod
  def tearDownClass(cls):
    cls.driver.quit()


if __name__ == '__main__':
  unittest.main(verbosity = 2)
```

### Manejar dropdown y listas

Lo que hicismos en esta clase fue tomar las opciones de un dropdown:

select_language.py:

```python
import unittest
from pyunitreport import HTMLTestRunner
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import Select #As√≠ podremos elegir las opciones de un dropdown

class LanguageOptions(unittest.TestCase):

  @classmethod
  def setUpClass(cls):
    options = Options()
    options.add_argument('--headless')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    cls.driver = webdriver.Chrome(executable_path = '/usr/bin/chromedriver' , options=options)
    driver = cls.driver
    driver.get('http://demo-store.seleniumacademy.com/')


  def test_select_language(self):
    exposed_options = ['English', 'French', 'German'] # Los lenguajes disponibles de la p√°gina web, en ese orden
    active_options = []

    select_language = Select(self.driver.find_element_by_id('select-language'))

    self.assertEqual(3, len(select_language.options))

    for option in select_language.options:
      active_options.append(option.text) #Agregamos el texto a la lista

    self.assertListEqual(exposed_options, active_options) # Comparamos ambas listas, si son id√©nticas, la prueba pasar√°

    self.assertEqual('English', select_language.first_selected_option.text) #Verificamos que 'English' es la primera opci√≥n por defecto

    select_language.select_by_visible_text('German') #Verificamos que existe la opci√≥n con texto 'German'

    self.assertTrue('store=german' in self.driver.current_url) #Esta es parte de la URL con idioma en alem√°n

    select_language = Select(self.driver.find_element_by_id('select-language'))
    select_language.select_by_index(0) #√çndex 0 es English, 1 es French y 2 es German


  @classmethod
  def tearDownClass(cls):
    cls.driver.quit()


if __name__ == '__main__':
  unittest.main(verbosity = 2)
```

### Manejar alert y pop-up

En esta clase logramos obtener el texto de un alert y cerrarlo.

alerts.py:

```python
import unittest
from pyunitreport import HTMLTestRunner
from selenium import webdriver
from selenium.webdriver.chrome.options import Options

class CompareProducts(unittest.TestCase):

  @classmethod
  def setUpClass(cls):
    options = Options()
    options.add_argument('--headless')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    cls.driver = webdriver.Chrome(executable_path = '/usr/bin/chromedriver' , options=options)
    driver = cls.driver
    driver.get('http://demo-store.seleniumacademy.com/')


  def test_compare_products_removal_alert(self):
    driver = self.driver
    search_field = driver.find_element_by_name('q')
    search_field.clear() # Limpiamos el texto que haya en la barra de b√∫squeda, como buena pr√°ctica

    search_field.send_keys('tee') #Simulamos que tecleamos 'tee'
    search_field.submit()

    driver.find_element_by_class_name('link-compare').click()
    driver.find_element_by_link_text('Clear All').click()

    alert = driver.switch_to.alert #Como saldra un alert, le decimos al navegador que centre su atenci√≥n aqu√≠
    alert_text = alert.text

    self.assertEqual('Are you sure you would like to remove all products from your comparison?', alert_text) #Validamos si el texto del alert es id√©ntico al que tenemos en la variable

    alert.accept() #Hacemos click en el bot√≥n de aceptar


  @classmethod
  def tearDownClass(cls):
    cls.driver.quit()


if __name__ == '__main__':
  unittest.main(verbosity = 2)
```

### Automatizar navegaci√≥n

[23 comandos esenciales de Selenium WebDriver](https://www.techbeamers.com/important-selenium-webdriver-commands/)

En esta clase pudimos navegar en la web de manera autom√°tica

automatic_navigation.py

```python
import unittest
from pyunitreport import HTMLTestRunner
from selenium import webdriver
from selenium.webdriver.chrome.options import Options

class NavigationTest(unittest.TestCase):

  @classmethod
  def setUpClass(cls):
    options = Options()
    options.add_argument('--headless')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    cls.driver = webdriver.Chrome(executable_path = '/usr/bin/chromedriver' , options=options)
    driver = cls.driver
    driver.get('https://google.com')

  def test_browser_navigation(self):
    driver = self.driver

    search_field = driver.find_element_by_name('q')
    search_field.clear()
    search_field.send_keys('platzi')
    search_field.submit()

    driver.back() #Retroceder en la navegaci√≥n web
    driver.forward() #Avanzar en la navegaci√≥n web
    driver.refresh() #Actualizar ventana del navegador


  @classmethod
  def tearDownClass(cls):
    cls.driver.quit()


if __name__ == '__main__':
  unittest.main(verbosity = 2)
```

## Sincronizar pruebas

### Demora impl√≠cita y expl√≠cita

Las pausas son buenas para el asincronismo.

Tenemos 2 tipos de demoras en Selenium:

- Impl√≠cita: busca uno o varios elementos en el DOM si no se encuentran disponibles por la cantidad de tiempo asignado. -> Ejemplo: `implicitly_wait(10)`
- Expl√≠cita: utiliza condiciones de espera determinados y contin√∫a hasta que se cumplan.

### Condicionales esperadas

[PDF con Condicionales esperadas](https://static.platzi.com/media/public/uploads/archivo_complementario_condicionales_esperadas_7204dca9-869e-4e49-a1a6-43e0c0c224e8.pdf)

waits.py:

```python
import unittest
from pyunitreport import HTMLTestRunner
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait #Nos ayudar√° con las esperas expl√≠citas
from selenium.webdriver.support import expected_conditions as EC

class ExplicitWaitTests(unittest.TestCase):
  @classmethod
  def setUpClass(cls):
    options = Options()
    options.add_argument('--headless')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    cls.driver = webdriver.Chrome(executable_path = '/usr/bin/chromedriver' , options=options)
    driver = cls.driver
    driver.get('http://demo-store.seleniumacademy.com/')


  def test_account_link(self):
    WebDriverWait(self.driver, 10).until(lambda s: s.find_element_by_id('select-language').get_attribute('length') == '3')
    # esperar√° 10 segundos hasta que se cumpla la condici√≥n, est√° en una lambda function

    account = WebDriverWait(self.driver, 10).until(EC.visibility_of_element_located((By.LINK_TEXT, 'ACCOUNT')))
    account.click()

  def test_create_new_customer(self):
    self.driver.find_element_by_link_text('ACCOUNT').click()

    my_account = WebDriverWait(self.driver, 10).until(EC.visibility_of_element_located((By.LINK_TEXT, 'My Account')))
    my_account.click()

    create_account_button = WebDriverWait(self.driver, 20).until(EC.element_to_be_clickable((By.LINK_TEXT, 'CREATE AN ACCOUNT')))
    create_account_button.click()

    WebDriverWait(self.driver, 10).until(EC.title_contains('Create New Customer Account'))

  @classmethod
  def tearDownClass(cls):
    cls.driver.quit()


if __name__ == '__main__':
  unittest.main(verbosity = 2)
```

### Condicionales esperadas, tabla

Expected Condition|Descripci√≥n|Ejemplo
---|---|---
element_to_be_clickable(locator)|Espera a que el elemento sea visible y habilitado para hacer clic en el mismo|WebDriverWait(self.driver,10).until(expected_conditions.element_to_be_clickable((By.NAME,‚Äúaccept_button‚Äù)))
element_to_be_selected(element)|Espera a que un elemento sea seleccionado|subscription = self.driver.find_element_by_name(‚Äúterms‚Äù). WebDriverWait(self.driver, 10).until(expected_conditions.element_to_be_selected(terms)))
invisibility_of_element_located(locator)|Espera a que un elemento no sea visible o no se encuentre presente en el DOM|WebDriverWait(self.driver,10).until(expected_conditions.invisibility_of_element_located((By.ID,‚Äúloading_banner‚Äù)))
presence_of_all_elements_located(locator)|Espera a que por lo menos uno de los elementos que se indican coincida con los presentes en el sitio|WebDriverWait(self.driver,10).until(expected_conditions.presence_of_all_elements_located((By.CLASS_NAME,‚Äúinput-text‚Äù)))
presence_of_element_located(locator)|Espera a que un elemento sea visible se encuentre presente en el DOM|WebDriverWait(self.driver,10).until(expected_conditions.presence_of_element_located((By.ID,‚Äúsearch-bar‚Äù)))
text_to_be_present_in_element(locator,text_)|Espera a que un elemento con el texto indicado se encuentre presente|WebDriverWait(self.driver,10).until(expected_conditions.text_to_be_present_in_element((By.ID,‚Äúseleorder‚Äù),‚Äúhigh‚Äù))
title_contains(title)|Espera a que la p√°gina contenga en el t√≠tulo exactamente como es indicado|WebDriverWait(self.driver, 10).until(expected_conditions.title_contains(‚ÄúWelcome‚Äù))
title_is(title)|Espera a que la p√°gina tenga un t√≠tulo id√©ntico a como es indicado|WebDriverWait(self.driver, 10).until(expected_conditions.title_is(‚ÄúWelcome to Platzi‚Äù))
visibility_of(element)|Espera a que el elemento indicado est√© en el DOM, sea visible, su alto y ancho sean mayores a cero|first_name = self.driver.find_element_by_id(‚Äúfirstname‚Äù) WebDriverWait(self.driver, 10).until(expected_conditions.visibility_of(first_name))
visibility_of_element_located(locator)|Espera a que el elemento indicado por su selector est√© en el DOM, sea visible y que su alto y ancho sean mayores a cero|WebDriverWait(self.driver,10).until(expected_conditions.visibility_of_element_located((By.ID,‚Äúfirstname‚Äù)))

## Retos

[Sitio web de los retos](https://the-internet.herokuapp.com/)

### Agregar y eliminar elementos

Pudimos agregar y eliminar elementos con una p√°gina web de prueba, la cual es [esta](https://the-internet.herokuapp.com/add_remove_elements/)

add_remove_elements.py:

```python
import unittest
from pyunitreport import HTMLTestRunner
from selenium import webdriver
from selenium.webdriver.chrome.options import Options

class AddRemoveElements(unittest.TestCase):

  @classmethod
  def setUpClass(cls):
    options = Options()
    options.add_argument('--headless')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    cls.driver = webdriver.Chrome(executable_path = '/usr/bin/chromedriver' , options=options)
    driver = cls.driver
    driver.get('https://the-internet.herokuapp.com/add_remove_elements/')


  def test_add_remove(self):
    driver = self.driver

    elements_added = int(input('How many elements will you add?: '))
    elements_removed = int(input('How many elements will you remove?: '))
    total_elements = elements_added - elements_removed

    add_button = driver.find_element_by_xpath('//*[@id="content"]/div/button')

    for i in range(elements_added):
      add_button.click() #Hacemos click en cada bot√≥n

    for i in range(elements_removed):
      try:
        #delete_button = driver.find_element_by_xpath('//*[@id="elements"]/button[1]')
        delete_button = driver.find_element_by_class_name('added-manually')
        delete_button.click()
      except:
        print("You're trying to delete more elements than the existent")
        break

    if total_elements > 0:
      print(f'There are {total_elements} elements on the screen')
    else:
      print(f'There are 0 elements on the screen')


  @classmethod
  def tearDownClass(cls):
    cls.driver.quit()


if __name__ == '__main__':
  unittest.main(verbosity = 2)
```

### Elementos din√°micos

La p√°gina usada en esta clase es [esta](https://the-internet.herokuapp.com/disappearing_elements)

**Contexto:** En esta p√°gina hay varios botones, 1 de ellos a veces aparece y a veces no.

Creamos un script que recargar√° la p√°gina tantas veces como sea necesario hasta que el bot√≥n est√© visible.

dynamic_elements.py:

```python
import unittest
from pyunitreport import HTMLTestRunner
from selenium import webdriver
from selenium.webdriver.chrome.options import Options

class DynamicElements(unittest.TestCase):

  @classmethod
  def setUpClass(cls):
    options = Options()
    options.add_argument('--headless')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    cls.driver = webdriver.Chrome(executable_path = '/usr/bin/chromedriver' , options=options)
    driver = cls.driver
    driver.get('https://the-internet.herokuapp.com/disappearing_elements')


  def test_name_elements(self):
    driver = self.driver

    options = []
    menu = 5
    tries = 1

    while len(options) < 5:
      options.clear() #Limpiamos la lista en caso de reiniciar el bucle while

      for i in range(menu):
        try:
          option_name = driver.find_element_by_xpath(f'//*[@id="content"]/div/ul/li[{i + 1}]/a')
          options.append(option_name.text)
          print(options)
        except: #Entrar√° aqu√≠ si solo encuentra 4 elemetos, ya que range(menu) llega a 5
          print(f'Option number {i + 1} is NOT FOUND')
          tries += 1
          driver.refresh()

    print(f'Finished in {tries} tries')


  @classmethod
  def tearDownClass(cls):
    cls.driver.quit()


if __name__ == '__main__':
  unittest.main(verbosity = 2)
```

### Controles din√°micos

**IMPORTANTE**: TODAS LAS FUNCIONES DE SELENIUM DEBEN EMPEZAR CON 'test', de lo contrario, no se ejecutar√°n.

Esta vez usamos [esta p√°gina web](https://the-internet.herokuapp.com/dynamic_controls)

dynamic_controls.py:

```python
import unittest
from pyunitreport import HTMLTestRunner
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium import webdriver
from selenium.webdriver.chrome.options import Options

class DynamicControls(unittest.TestCase):
  @classmethod
  def setUpClass(cls):
    options = Options()
    options.add_argument('--headless')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    cls.driver = webdriver.Chrome(executable_path = '/usr/bin/chromedriver' , options=options)
    driver = cls.driver
    driver.get('https://the-internet.herokuapp.com/dynamic_controls')


  def test_addRemoveCheckBox(self):
    driver = self.driver

    #Conseguir los elemetos
    check_box = driver.find_element_by_css_selector('#checkbox')
    add_remove_button = driver.find_element_by_css_selector('#checkbox-example > button')

    #Interactuar con los elementos
    check_box.click()
    add_remove_button.click()
    WebDriverWait(driver, 15).until(EC.element_to_be_clickable((By.CSS_SELECTOR, '#checkbox')))
    add_remove_button.click()


  def test_write_in_input_field(self):
    driver = self.driver

    #Conseguir los elemetos
    enable_disable_button = driver.find_element_by_css_selector('#input-example > button')
    input_field = driver.find_element_by_css_selector('#input-example > input[type=text]')

    #Interactuar con los elementos
    enable_disable_button.click()
    WebDriverWait(driver, 15).until(EC.element_to_be_clickable((By.CSS_SELECTOR, '#input-example > button')))
    input_field.clear() #En caso de que tenga texto escrito
    input_field.send_keys('Platzi')
    enable_disable_button.click()


  @classmethod
  def tearDownClass(cls):
    cls.driver.quit()


if __name__ == '__main__':
  unittest.main(verbosity = 2)
```

### Typos

Vamos a valiar que el texto de un sitio web sea id√©ntico a uno que esperamos.

typos.py:

```python
import unittest
from selenium import webdriver
from selenium.webdriver.chrome.options import Options

class Typos(unittest.TestCase):
  @classmethod
  def setUpClass(cls):
    options = Options()
    options.add_argument('--headless')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    cls.driver = webdriver.Chrome(executable_path = '/usr/bin/chromedriver' , options=options)
    driver = cls.driver
    driver.get('https://the-internet.herokuapp.com/typos')


  def test_find_typo(self):
    driver = self.driver

    paragraph_to_check = driver.find_element_by_css_selector('#content > div > p:nth-child(3)')
    text_to_check = paragraph_to_check.text
    print(f'Text to check: {text_to_check}')
    print(f'Paragraph to check {paragraph_to_check.text}')

    tries = 1
    found = False
    correct_text = "Sometimes you'll see a typo, other times you won't."

    while text_to_check != correct_text:
      paragraph_to_check = driver.find_element_by_css_selector('#content > div > p:nth-child(3)')
      text_to_check = paragraph_to_check.text
      tries += 1
      driver.refresh()

    while not found:
      if text_to_check == correct_text:
        driver.refresh()
        found = True

    self.assertEqual(found, True)

    print(f'It took {tries} tries to find the typo')


  @classmethod
  def tearDownClass(cls):
    cls.driver.quit()


if __name__ == '__main__':
  unittest.main(verbosity = 2)
```

### Ordenas tablas

Usamos [esta p√°gina para esta clase](https://the-internet.herokuapp.com/tables)

Logramos conseguir la informaci√≥n de la primera tabla con este c√≥digo:

tables.py

```python
import unittest
from selenium import webdriver
from selenium.webdriver.chrome.options import Options

class Typos(unittest.TestCase):
  @classmethod
  def setUpClass(cls):
    options = Options()
    options.add_argument('--headless')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    cls.driver = webdriver.Chrome(executable_path = '/usr/bin/chromedriver' , options=options)
    driver = cls.driver
    driver.get('https://the-internet.herokuapp.com/tables')


  def test_sort_tables(self):
    driver = self.driver

    table_data = [[] for i in range(5)]
    print(table_data)

    for i in range(5):
      header = driver.find_element_by_xpath(f'//*[@id="table1"]/thead/tr/th[{i + 1}]/span')
      table_data[i].append(header.text)

      for j in range(4):
        row_data = driver.find_element_by_xpath(f'//*[@id="table1"]/tbody/tr[{j + 1}]/td[{i + 1}]')
        table_data[i].append(row_data.text)

    print(table_data)


  @classmethod
  def tearDownClass(cls):
    cls.driver.quit()


if __name__ == '__main__':
  unittest.main(verbosity = 2)
```

## Metodolog√≠as de Trabajo

### Data Driven Testing (DDT)

Esta es una metodolog√≠a usada en el testing de software. Nos ayudan a que las automatizaciones sean m√°s robustas y vers√°tiles.

**NO confundir con:** TDD.

Diferencias:

- Test Driven Development: desarrollar c√≥digo en base a pruebas para que pueda cumplirlas.
- Data Driven Testing: desarrollar pruebas en base a c√≥digo ya existente para validar en qu√© escenarios pasan o fallan.

Ejemplo de formulario: Si el usuario debe ingresar una cantidad de dinero (entero), e inserta "5000" (sin comillas), se tomar√° como algo correcto. Pero si ingresa "$5000.00,00" (sin comillas), esto debe marcar un error.

**Importante**: para esta clase usamos ddt y hay que instalarlo con `pip install ddt`

Creamos 2 archivos, uno para comparar si hay X cantidad de elementos en el sitio web:

search_ddt.py:

```python
import unittest
from ddt import ddt, data, unpack
from selenium import webdriver
from selenium.webdriver.chrome.options import Options

@ddt
class searchDDT(unittest.TestCase):

  @classmethod
  def setUpClass(cls):
    options = Options()
    options.add_argument('--headless')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    cls.driver = webdriver.Chrome(executable_path = '/usr/bin/chromedriver' , options=options)
    driver = cls.driver
    driver.get('http://demo-store.seleniumacademy.com/')


  @data(('dress', 5), ('music', 5)) #Creamos 2 tuplas
  @unpack


  def test_search_ddt(self, search_value, expected_count):
    driver = self.driver

    search_field = driver.find_element_by_name('q')
    search_field.clear()
    search_field.send_keys(search_value)
    search_field.submit()

    products = driver.find_elements_by_xpath('//h2[@class="product-name"]/a') #h2 con la clase product-name y adentro hay un ancla
    print(f'Found {len(products)} products')

    for product in products:
      print(product.text)

    self.assertEqual(expected_count, len(products))


  @classmethod
  def tearDownClass(cls):
    cls.driver.quit()


if __name__ == '__main__':
  unittest.main(verbosity = 2)
```

Creamos un sencillo archivo csv y comparamos si en el sitio web hay la misma cantidad de elementos que en csv:

search_csv_ddt.py:

```python
import csv, unittest
from ddt import ddt, data, unpack
from selenium import webdriver
from selenium.webdriver.chrome.options import Options

def get_data(file_name):
  rows = []
  data_file = open(file_name, 'r')
  reader = csv.reader(data_file)
  next(reader, None) #Hacemos esto para omitir la cabecera del archivo csv

  for row in reader:
    rows.append(row)
  return rows


@ddt
class searchDDT(unittest.TestCase):

  @classmethod
  def setUpClass(cls):
    options = Options()
    options.add_argument('--headless')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    cls.driver = webdriver.Chrome(executable_path = '/usr/bin/chromedriver' , options=options)
    driver = cls.driver
    driver.get('http://demo-store.seleniumacademy.com/')


  @data(*get_data('testdata.csv'))
  @unpack


  def test_search_ddt(self, search_value, expected_count):
    driver = self.driver

    search_field = driver.find_element_by_name('q')
    search_field.clear()
    search_field.send_keys(search_value)
    search_field.submit()

    products = driver.find_elements_by_xpath('//h2[@class="product-name"]/a') #h2 con la clase product-name y adentro hay un ancla

    expected_count = int(expected_count)

    if expected_count > 0:
      self.assertEqual(expected_count, len(products))
    else:
      message = driver.find_element_by_class_name('note-msg')
      self.assertEqual('Your search returns no results.', message)

    print(f'Found {len(products)} products')


  @classmethod
  def tearDownClass(cls):
    cls.driver.quit()


if __name__ == '__main__':
  unittest.main(verbosity = 2)
```

### Page Object Model (POM)

Es un patr√≥n de dise√±o utilizado en testing. En vez de manejar las pruebas en 1 mismo archivo, tendremos las pruebas en distintos archivos.

Beneficios:

- Crea un alto nivel de abstracci√≥n para minizar cambios en las pruebas si los desarrolladores modifican el sitio.
- Crea c√≥digo reutilizable que se puede utilizar en m√∫tiples pruebas.
- Las pruebas son m√°s legibles, flexibles y vigentes.

Hay que tomar en cuenta que si las pruebas son peque√±as, POM quiz√°s las haga complejas. Pero si tus pruebas son grandes, te ayudar√° a hacerlo m√°s f√°cil.

Creamos el archivo donde tenemos todas las pruebas en distintas funciones:

google_page.py:

```python
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

class GooglePage(object):
  def __init__(self, driver):
    self._driver = driver
    self._url = 'https://google.com'
    self.search_locator = 'q'

  @property
  def is_loaded(self):
    WebDriverWait(self._driver, 10).until(EC.presence_of_element_located((By.NAME , 'q')))
    return True

  @property
  def keyword(self):
    input_field = self._driver.find_element_by_name('q')
    return input_field.get_attribute('value')


  def open(self):
    self._driver.get(self._url)


  def type_search(self, keyword):
    input_field = self._driver.find_element_by_name('q')
    input_field.send_keys(keyword)


  def click_submit(self):
    input_field = self._driver.find_element_by_name('q')
    input_field.submit()


  def search(self, keyword):
    self.type_search(keyword)
    self.click_submit()
```

Y en el otro archivo, mandamos a llamar a las funciones y pasamos los valores:

test_google.py:

```python
import unittest
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from google_page import GooglePage #Nos estamos trayendo la clase del otro archivo

class GoogleTest(unittest.TestCase):
  @classmethod
  def setUpClass(cls):
    options = Options()
    options.add_argument('--headless')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    cls.driver = webdriver.Chrome(executable_path = '/usr/bin/chromedriver' , options=options)


  def test_search(self):
    google = GooglePage(self.driver)
    google.open()
    google.search('Platzi')

    self.assertEqual('Platzi', google.keyword)


  @classmethod
  def tearDownClass(cls):
    cls.driver.quit()


if __name__ == '__main__':
  unittest.main(verbosity = 2)
```

## Cierre del curso

### Realizar una prueba t√©cnica

Consideraciones:

- Practicar en sitios complejos
- Preguntar acerca de las expectativas
- Define paso a paso el flujo
- Piensa como usuario final
- Programa como desarrollador

Prueba: Flujo en Mercado Libre

1. Ingresar a [Mercado libre](https://www.mercadolibre.com/)
2. Seleccionar 'Colombia' como pa√≠s.
3. Buscar el t√©rmino 'playstation4'.
4. Filtrar por condici√≥n 'Nuevos'.
5. Filtrar por ubicaci√≥n 'Bogot√°'.
6. Ordenar de mayor a menor precio.
7. Obtener el nombre y precio de los primeros 5 art√≠culos.

## Examen

- ¬øCon qu√© me permite interactuar la clase WebElement de Selenium?: elementos del sitio web
- ¬øCu√°l es la diferencia entre DDT y TDD?: DDT es testing con c√≥digo ya escrito. TDD es c√≥digo basado en pruebas para pasarlas
- ¬øQu√© librer√≠as complementan Selenium para generar pruebas efectivas?: unittest pyunitreport ddt
- ¬øQu√© acciones podemos utilizar para interactuar con un alert de JavaScript?: Aceptar, extraer texto y enviar texto XXXX aceptar, cerrar ventana, maximizar ventana XXXX cambiar de pesta√±a, aceptar y rechazar XXXX
- ¬øC√≥mo valido que el bot√≥n con nombre "signup" est√° a la vista y habilitado?: el que est√° en singular xd
- ¬øQu√© es y para qu√© nos sirven las test suites?: colecci√≥n para validar comportamiento
- ¬øCu√°ndo es conveniente utilizar try y except en nuestra prueba?: no conocemos el sitio y es din√°mico
- ¬øQu√© hace el siguiente c√≥digo?: espera hasta 10 segundos el texto account
- ¬øPor qu√© no deber√≠a automatizar o hacer testing en sitios que expl√≠citamente lo proh√≠ben?: √©tica
- ¬øCu√°ndo es buena idea usar XPath como selector?: cuando no hay otro selector √∫nico
- ¬øQu√© lenguaje no es soportado oficialmente con Selenium?: Dart
- ¬øQu√© hace el siguiente c√≥digo?: introduce texto y presiona enter
- ¬øQu√© es una expected condition (condici√≥n esperada)?: intervenci√≥n humana XXXX √∫nicamente XXXX condiciones predefinidas o personalizadas a las que el script espera XXXX definir errores XXXX
- ¬øQu√© assertion te permite validar el que el t√≠tulo del sitio web es el siguiente?üöÄPlatzi: ‚ÄéCursos Online Profesionales de Tecnolog√≠a: assertEqual

- ¬øC√≥mo extraemos el valor del atributo ‚Äòautocomplete‚Äô del siguiente elemento?: name y attribute
- ¬øCu√°l es el principal beneficio de Page Object Model (POM)?: mejor mantenimiento
- Son debilidades de Selenium: manejo de asincronismo y generaci√≥n de reportes
- ¬øQu√© hace el siguiente c√≥digo?: busca nombre y selecciona valor
- Tienes una barra de b√∫squeda cuyo nombre es name="q" ¬øCon qu√© c√≥digo accedes a esta?: find element by name q
- ¬øQu√© hace el siguiente c√≥digo?: espera hasta 20 segundos a que cargue alg√∫n elemento
- ¬øCu√°les son los componentes vigentes de la suite de Selenium?: webdriver, ide, grid
- ¬øQu√© es Selenium?; suite para automatizar el navegador
- Son todos m√©todos para automatizar la navegaci√≥n: back, forward, refresh, find_eelement_by XXXX back, forward, navigate, refresh, close XXXX el que tiene get url XXXX
- ¬øCu√°les son consideraciones al presentar una prueba t√©cnica?: tener claro los pasos y pensar como usuario
- ¬øPor qu√© debemos utilizar la menor cantidad de esperas impl√≠citas posibles?: para que no sea lenta
- ¬øCon qu√© me permite interactuar la clase WebDriver de Selenium?: navegador; ventana, alerts
- Los m√©todos setUp() y tearDown() son para: ejectuar todas las pruebas en una sola instancia del navegador XXXX formalidad XXXX realizar acciones espec√≠ficas
